import { Response } from "undici";
import { isEmpty } from "lodash";
import { ResponseError } from "vscode-jsonrpc/lib/messages";
import {
	ERROR_GENERIC_USE_ERROR_MESSAGE,
	ERROR_VM_NOT_SETUP,
	GetLibraryDetailsRequest,
	GetLibraryDetailsResponse,
	GetLibraryDetailsType,
	LibraryDetails,
	RiskSeverity,
	SeverityType,
	ThirdPartyDisconnect,
	Vulnerability,
	severityList,
} from "@codestream/protocols/agent";

import { SessionContainer } from "../../../container";
import { Logger } from "../../../logger";
import { Disposable, log, lsp, lspHandler } from "../../../system";
import { EntityLibraries, VulnerabilityPackage, VulnerableLibrary } from "./types";
import { ExtraRequestInit } from "../../../system/fetchCore";
import Cache from "@codestream/utils/system/timedCache";
import { CSNewRelicProviderInfo } from "@codestream/protocols/api";
import { HttpClient } from "../../../api/httpClient";

const API_TIMEOUT = 30000;

const options: ExtraRequestInit = {
	timeout: API_TIMEOUT,
};

export type NrSecError = {
	timestamp?: number;
	status?: number;
	error?: string;
	message?: string;
	path?: string;
};

export function isNrSecError(obj: unknown): obj is NrSecError {
	const maybe = obj as NrSecError;
	return (
		typeof maybe.timestamp === "number" &&
		typeof maybe.status === "number" &&
		!isEmpty(maybe.error) &&
		!isEmpty(maybe.message) &&
		!isEmpty(maybe.path)
	);
}

const severityScore: Record<SeverityType, number> = {
	CRITICAL: 5,
	HIGH: 4,
	MODERATE: 3,
	LOW: 2,
};

function isCriticalityType(maybe: unknown): maybe is SeverityType {
	return severityList.includes(maybe as SeverityType);
}

function maxCriticality(
	packages: VulnerabilityPackage[],
	highestCriticality: SeverityType = "LOW"
): SeverityType {
	let mostCritital = highestCriticality;

	if (!isCriticalityType(mostCritital)) {
		return mostCritital;
	}

	packages.map(p => {
		if (severityScore[mostCritital] < severityScore[p.severity]) {
			mostCritital = p.severity;
		}
	});

	return mostCritital;
}

@lsp
export class NewRelicVulnerabilitiesProvider implements Disposable {
	private libraryDataCache = new Cache<EntityLibraries>({ defaultTtl: 1800 * 1000 }); // 30 minutes

	constructor(
		private providerInfo: CSNewRelicProviderInfo,
		private httpClient: HttpClient | undefined
	) {}

	get displayName(): string {
		return "New Relic Vulnerability Management";
	}

	get headers(): { [p: string]: string } {
		const accessToken = this.providerInfo.accessToken;
		if (!accessToken) {
			throw new Error(`nrVulnerability: missing accessToken`);
		}
		return {
			[this.providerInfo.tokenType === "id" ? "x-id-token" : "x-access-token"]: accessToken,
			"Content-Type": "application/json",
		};
	}

	get baseUrl(): string {
		return this.apiUrl;
	}

	get apiUrl() {
		const newRelicSecApiUrl = SessionContainer.instance().session.newRelicSecApiUrl;
		Logger.log(`*** newRelicSecApiUrl: ${newRelicSecApiUrl}`);
		return newRelicSecApiUrl ?? "https://nrsec-workflow-api.staging-service.newrelic.com";
	}

	get productUrl() {
		return this.apiUrl.indexOf("staging") > -1
			? "https://staging-one.newrelic.com/vulnerability-management"
			: "https://one.newrelic.com/vulnerability-management";
	}

	@log()
	async onDisconnected(request?: ThirdPartyDisconnect) {
		this.libraryDataCache.clear();

		// return super.onDisconnected(request);
	}

	protected attemptJson(body: string): object | undefined {
		try {
			return JSON.parse(body);
		} catch (ex) {
			return undefined;
		}
	}

	protected async handleErrorResponse(response: Response): Promise<Error> {
		if (!this.httpClient) {
			throw new Error(`nrVulnerability: httpClient not set`);
		}
		const body = await response.text();
		const json = this.attemptJson(body);
		if (!json) {
			Logger.warn(
				`Unknown error, non-json response: ${response.status} ${response.statusText} ${body}`
			);
		}
		if (isNrSecError(json)) {
			if (json.error === "Forbidden" && json.status === 403) {
				return new ResponseError<{ url: string }>(ERROR_VM_NOT_SETUP, "VM possibly not setup", {
					url: this.productUrl,
				});
			} else {
				Logger.warn(`Unknown error: ${json.status} ${json.error}: ${json.message}`);
				return new ResponseError(ERROR_GENERIC_USE_ERROR_MESSAGE, "Unknown error");
			}
		}
		return this.httpClient.handleErrorResponse(response);
	}

	@lspHandler(GetLibraryDetailsType)
	@log()
	async getLibraryDetails(request: GetLibraryDetailsRequest): Promise<GetLibraryDetailsResponse> {
		const data = await this.doGetLibraryDetails(request);
		const { rows = 5 } = request;
		const libraries = rows === "all" ? data : data.slice(0, rows);
		return {
			libraries,
			recordCount: libraries.length,
			totalRecords: data.length,
		};
	}

	riskSeverityToVulnerabilitySeverity(riskSeverity: RiskSeverity): SeverityType {
		switch (riskSeverity) {
			case "CRITICAL":
				return "CRITICAL";
			case "HIGH":
				return "HIGH";
			case "MEDIUM":
				return "MODERATE";
			default:
				return "LOW";
		}
	}

	processLibraries(libraries: Array<VulnerableLibrary>, severityFilter?: RiskSeverity[]) {
		const libraryDetails = new Array<LibraryDetails>();
		for (const library of libraries) {
			const vulnerabilities = library.includedVersions?.[0]?.vulnerabilities;
			if (!vulnerabilities || vulnerabilities.length === 0) {
				continue;
			}

			let highestScore = 0;
			let highestSeverityForLibrary: SeverityType = "LOW";
			const vulnResponse = new Array<Vulnerability>();
			for (const vulnerability of vulnerabilities) {
				if (library.language && library.language !== vulnerability.language) {
					continue;
				}

				const highestSeverityForVulnerability = maxCriticality(vulnerability.packages);

				const filterValues = severityFilter?.map(this.riskSeverityToVulnerabilitySeverity);
				if (filterValues && !isEmpty(filterValues)) {
					if (!filterValues.includes(highestSeverityForVulnerability)) {
						continue;
					}
				}

				highestSeverityForLibrary = maxCriticality(
					vulnerability.packages,
					highestSeverityForLibrary
				);
				highestScore = Math.max(highestScore, vulnerability.score);

				vulnResponse.push({
					severity: highestSeverityForVulnerability,
					description: vulnerability.description,
					cveId: vulnerability.cveId,
					score: vulnerability.score,
					title: vulnerability.title,
					url: vulnerability.url,
					vector: vulnerability.vector,
				});
			}

			vulnResponse.sort((a, b) => b.score - a.score);

			if (vulnResponse.length > 0) {
				libraryDetails.push({
					name: library.name,
					version: library.includedVersions?.[0]?.version ?? "unknown",
					suggestedVersion: library.suggestedVersion?.version,
					language: library.language,
					highestScore,
					highestSeverity: highestSeverityForLibrary,
					vulnerabilities: vulnResponse,
				});
			}
		}
		return libraryDetails;
	}

	async doGetLibraryDetails(request: GetLibraryDetailsRequest): Promise<Array<LibraryDetails>> {
		const { entityGuid, accountId } = request;
		const allLibraries = await this.fetchLibraries(entityGuid, accountId);
		const filteredLibraries = allLibraries.libraries.filter(_ => {
			if (!_.includedVersions) {
				return false;
			}

			let count = 0;
			for (const i of _.includedVersions) {
				count += i.allVulnerabilities;
			}

			return count > 0;
		});

		return this.processLibraries(filteredLibraries, request.severityFilter);
	}

	private async fetchLibraries(entityGuid: string, accountId: number): Promise<EntityLibraries> {
		if (!this.httpClient) {
			throw new Error(`nrVulnerability: httpClient not set`);
		}
		const cached = this.libraryDataCache.get({ entityGuid, accountId });
		if (cached) {
			Logger.debug("Fetch libraries got from cache");
			return cached;
		}
		Logger.debug("Fetch libraries NOT in cache");
		const path = `/v1/inventory/accounts/${accountId}/entities/${entityGuid}/libraries?includeVulnerabilities=true`;
		const response = await this.httpClient.get<EntityLibraries>(path, undefined, options);
		this.libraryDataCache.put({ entityGuid, accountId }, response.body);
		return response.body;
	}

	/*
  Not actually used - agent is restarted at logout but keeping for
  possible future use
  */
	dispose(): void {
		this.libraryDataCache.clear();
		delete this.httpClient;
	}
}
