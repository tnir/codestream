import { URLSearchParams } from "url";

import { Response } from "node-fetch";
import { chunk, isEmpty } from "lodash";
import Cache from "timed-cache";
import { ResponseError } from "vscode-jsonrpc/lib/messages";
import * as semver from "semver";
import {
	criticalityList,
	CriticalityType,
	ERROR_GENERIC_USE_ERROR_MESSAGE,
	ERROR_VM_NOT_SETUP,
	GetLibraryDetailsRequest,
	GetLibraryDetailsResponse,
	GetLibraryDetailsType,
	GetSecurityIssuesForEntityRequest,
	GetSecurityIssuesForEntityResponse,
	GetSecurityIssuesForEntityType,
	LibraryDetails,
	RiskSeverity,
	SecurityIssueSummaryResponse,
	ThirdPartyDisconnect,
	ThirdPartyProviderConfig,
	Vuln,
} from "@codestream/protocols/agent";

import { SessionContainer } from "../../../container";
import { Logger } from "../../../logger";
import { CodeStreamSession } from "../../../session";
import { log, lspHandler, lspProvider } from "../../../system";
import { ThirdPartyProviderBase } from "../../thirdPartyProviderBase";
import { EntityLibraries, LibraryUsage, VulnerabililityDetails, VulnerableLibrary } from "./types";

const API_TIMEOUT = 30000;

const options = {
	timeout: API_TIMEOUT,
};

export type NrSecError = {
	timestamp?: number;
	status?: number;
	error?: string;
	message?: string;
	path?: string;
};

export function isNrSecError(obj: unknown): obj is NrSecError {
	const maybe = obj as NrSecError;
	return (
		typeof maybe.timestamp === "number" &&
		typeof maybe.status === "number" &&
		!isEmpty(maybe.error) &&
		!isEmpty(maybe.message) &&
		!isEmpty(maybe.path)
	);
}

const critScore: Record<CriticalityType, number> = {
	CRITICAL: 5,
	HIGH: 4,
	MODERATE: 3,
	LOW: 2,
};

function isCriticalityType(maybe: unknown): maybe is CriticalityType {
	return criticalityList.includes(maybe as CriticalityType);
}

function maxCriticalicy(highestCriticality: CriticalityType, criticality: string): CriticalityType {
	if (!isCriticalityType(criticality)) {
		return highestCriticality;
	}
	if (critScore[highestCriticality] < critScore[criticality]) {
		return criticality;
	} else {
		return highestCriticality;
	}
}

@lspProvider("newrelic-vulnerabilities")
export class NewRelicVulnerabilitiesProvider extends ThirdPartyProviderBase {
	private dataCache = new Cache<SecurityIssueSummaryResponse>({ defaultTtl: 1800 * 1000 }); // 30 minutes
	private libraryDataCache = new Cache<EntityLibraries>({ defaultTtl: 1800 * 1000 }); // 30 minutes
	private filterCache = new Cache<SecurityIssueSummaryResponse>({ defaultTtl: 300 * 1000 }); // 5 minutes
	// private libraryDetailsCache = new Cache<Array<LibraryDetails>>({ defaultTtl: 900 * 1000 }); // 15 minutes
	private libraryUsageCache = new Cache<LibraryUsage>({ defaultTtl: 1800 * 1000 }); // 30 minutes

	constructor(session: CodeStreamSession, config: ThirdPartyProviderConfig) {
		super(session, config);
	}

	get displayName(): string {
		return "New Relic Vulnerability Management";
	}

	get headers(): { [p: string]: string } {
		const accessToken = this.accessToken;
		if (!accessToken) {
			throw new Error(`Missing accessToken for ${this.name}`);
		}
		return {
			"Api-Key": accessToken,
			"Content-Type": "application/json",
		};
	}

	get name(): string {
		return "newrelic"; // Use existing providerInfo to get API key
	}

	get baseUrl(): string {
		return this.apiUrl;
	}

	get apiUrl() {
		const newRelicSecApiUrl = SessionContainer.instance().session.newRelicSecApiUrl;
		return newRelicSecApiUrl || "https://nrsec-workflow-api.staging-service.newrelic.com";
	}

	get productUrl() {
		return this.apiUrl.indexOf("staging") > -1
			? "https://staging-one.newrelic.com/vulnerability-management"
			: "https://one.newrelic.com/vulnerability-management";
	}

	@log()
	async onDisconnected(request?: ThirdPartyDisconnect) {
		this.dataCache.clear();
		this.filterCache.clear();
		this.libraryDataCache.clear();
		this.libraryUsageCache.clear();

		return super.onDisconnected(request);
	}

	@lspHandler(GetSecurityIssuesForEntityType)
	@log()
	async getSecurityIssuesForEntity(
		request: GetSecurityIssuesForEntityRequest
	): Promise<GetSecurityIssuesForEntityResponse> {
		const data = await this.getSecurityIssues(request);
		const { rows = 5 } = request;
		const securityIssues = rows === "all" ? data : data.slice(0, rows);
		return {
			securityIssues,
			recordCount: securityIssues.length,
			totalRecords: data.length,
		};
	}

	private async getSecurityIssues(
		request: GetSecurityIssuesForEntityRequest
	): Promise<SecurityIssueSummaryResponse> {
		let httpResponseCached: SecurityIssueSummaryResponse | undefined = this.dataCache.get("DATA");
		if (!httpResponseCached) {
			const response = await this.fetchSecurityIssues(request.entityGuid, request.accountId);
			this.dataCache.put("DATA", response);
			httpResponseCached = response;
			this.filterCache.clear();
		}
		const cachedFilter = this.filterCache.get(request);
		if (!cachedFilter) {
			if (!request.severityFilter) {
				this.filterCache.put(request, httpResponseCached);
				Logger.log(
					`getSecurityIssuesForEntity ${JSON.stringify(request)} ${
						httpResponseCached.length
					} not cached`
				);
				return httpResponseCached;
			} else {
				const filtered = httpResponseCached.filter(_ =>
					request.severityFilter?.includes(_.severity)
				);
				this.filterCache.put(request, filtered);
				Logger.log(
					`getSecurityIssuesForEntity ${JSON.stringify(request)} ${filtered.length} not cached`
				);
				return filtered;
			}
		} else {
			Logger.log(
				`getSecurityIssuesForEntity ${JSON.stringify(request)} ${cachedFilter.length} from cache`
			);
			return cachedFilter;
		}
	}

	private async fetchSecurityIssues(
		entityGuid: string,
		accountId: number
	): Promise<SecurityIssueSummaryResponse> {
		const queryString = new URLSearchParams({
			entities: `(id='${entityGuid}')`,
		}).toString();
		const path = `/v1/issues/accounts/${accountId}/?${queryString}`;
		const response = await this.get<SecurityIssueSummaryResponse>(path, undefined, options);
		return response.body;
	}

	protected async handleErrorResponse(response: Response): Promise<Error> {
		const body = await response.text();
		const json = JSON.parse(body);
		if (isNrSecError(json)) {
			if (json.error === "Forbidden" && json.status === 403) {
				return new ResponseError<{ url: string }>(ERROR_VM_NOT_SETUP, "VM possibly not setup", {
					url: this.productUrl,
				});
			} else {
				Logger.warn(`Unknown error: ${json.status} ${json.error}: ${json.message}`);
				return new ResponseError(ERROR_GENERIC_USE_ERROR_MESSAGE, "Unknown error");
			}
		}
		return super.handleErrorResponse(response);
	}

	@lspHandler(GetLibraryDetailsType)
	@log()
	async getLibraryDetails(request: GetLibraryDetailsRequest): Promise<GetLibraryDetailsResponse> {
		const data = await this.doGetLibraryDetails(request);
		const { rows = 5 } = request;
		const libraries = rows === "all" ? data : data.slice(0, rows);
		return {
			libraries,
			recordCount: libraries.length,
			totalRecords: data.length,
		};
	}

	riskSeverityToCriticality(riskSeverity: RiskSeverity): CriticalityType {
		switch (riskSeverity) {
			case "CRITICAL":
				return "CRITICAL";
			case "HIGH":
				return "HIGH";
			case "MEDIUM":
				return "MODERATE";
			case "LOW":
				return "LOW";
			default:
				return "LOW";
		}
	}

	findVulnsForVersion(
		version: string,
		usages: LibraryUsage,
		language?: string
	): Array<VulnerabililityDetails> | undefined {
		// This method seems better now than keying on version - TODO remove commented code in next pass
		return this.findVulnsForVersionBySemver(version, usages);
		// if (language === "java") {
		// } else {
		// 	return usages.vulnerabilities[version];
		// }
	}

	findVulnsForVersionBySemver(
		versionStr: string,
		usages: LibraryUsage
	): Array<VulnerabililityDetails> | undefined {
		const versionList = versionStr.split(",");
		const response = new Array<VulnerabililityDetails>();
		const alreadyAdded = new Set<string>();
		for (const [_, value] of Object.entries(usages.vulnerabilities)) {
			for (const finding of value) {
				if (alreadyAdded.has(finding.cve)) {
					continue;
				}
				for (const range of finding.versions) {
					const rangeString = range.join(" ");
					for (const version of versionList) {
						if (semver.satisfies(version, rangeString)) {
							if (alreadyAdded.has(finding.cve)) {
								continue;
							}
							response.push(finding);
							alreadyAdded.add(finding.cve);
						}
					}
				}
			}
		}
		return response;
	}

	async doGetLibraryDetails(request: GetLibraryDetailsRequest): Promise<Array<LibraryDetails>> {
		const { entityGuid, accountId } = request;
		const allLibraries = await this.fetchLibraries(entityGuid, accountId);
		const filteredLibraries = allLibraries.libraries.filter(_ => {
			let count = 0;
			for (const i of _.includedVersions) {
				count += i.criticalVulnerabilities + i.highVulnerabilities + i.otherVulnerabilities;
			}
			return count > 0;
		});

		// Parallel processing - split into 4 lists, process each chunk
		const chunks = chunk(filteredLibraries, Math.max(filteredLibraries.length / 4, 1));
		const libraryDetailsCombined = new Array<LibraryDetails>();
		const promises = chunks.map(chunk =>
			this.processLibraryChunk(accountId, chunk, request.severityFilter)
		);
		for (const promise of promises) {
			const result = await promise;
			libraryDetailsCombined.push(...result);
		}

		// API result comes in sorted (filteredLibraries) by weighted score (but weighted score not returned by api)
		// so we have to re-sort libraryDetailsCombined since the parallel processing could have changed the order

		libraryDetailsCombined.sort((a, b) => {
			return (
				filteredLibraries.findIndex(i => a.name === i.name) -
				filteredLibraries.findIndex(i => b.name === i.name)
			);
		});

		return libraryDetailsCombined;
	}

	private async processLibraryChunk(
		accountId: number,
		libraryChunk: Array<VulnerableLibrary>,
		severityFilter?: RiskSeverity[]
	): Promise<Array<LibraryDetails>> {
		const libraryDetails = new Array<LibraryDetails>();
		for (const library of libraryChunk) {
			const libraryVulnerabilities = await this.fetchLibraryVulnerabilities(
				accountId,
				library.name,
				library.language
			);
			const version = library.includedVersions[0].version; // TODO which one to choose? Cross-reference package.json?
			// const versionStringKey = Object.keys(vulnerabilities.vulnerabilities); // keys like "3.0.4, 2.0.10"
			if (!version) {
				continue;
			}
			const vulnerabilities = this.findVulnsForVersion(
				version,
				libraryVulnerabilities,
				library.language
			);
			if (!vulnerabilities) {
				continue;
			}

			let highestScore = 0;
			let highestCriticality: CriticalityType = "LOW";
			const vulnResponse = new Array<Vuln>();
			for (const finding of vulnerabilities) {
				const filterValues = severityFilter?.map(this.riskSeverityToCriticality);
				if (filterValues && !isEmpty(filterValues)) {
					if (!filterValues.includes(finding.criticality)) {
						continue;
					}
				}
				highestScore = Math.max(highestScore, finding.score);
				highestCriticality = maxCriticalicy(highestCriticality, finding.criticality);
				vulnResponse.push({
					criticality: finding.criticality,
					description: finding.description,
					issueId: finding.cve,
					remediation: finding.remediation,
					score: finding.score,
					title: finding.title,
					url: finding.url,
					source: finding.source ?? "New Relic",
					vector: finding.vector,
				});
			}

			vulnResponse.sort((a, b) => b.score - a.score);

			if (vulnResponse.length > 0) {
				libraryDetails.push({
					name: library.name,
					version: version ?? "unknown",
					suggestedVersion: library.suggestedVersion?.version,
					language: library.language,
					highestScore,
					highestCriticality,
					vulns: vulnResponse,
				});
			}
		}
		return libraryDetails;
	}

	private async fetchLibraries(entityGuid: string, accountId: number): Promise<EntityLibraries> {
		const cached = this.libraryDataCache.get({ entityGuid, accountId });
		if (cached) {
			return cached;
		}
		const path = `/v1/inventory/accounts/${accountId}/entities/${entityGuid}/libraries`;
		const response = await this.get<EntityLibraries>(path, undefined, options);
		this.libraryDataCache.put({ entityGuid, accountId }, response.body);
		return response.body;
	}

	private async fetchLibraryVulnerabilities(
		accountId: number,
		library: string,
		language?: string
	): Promise<LibraryUsage> {
		const cacheKey = { accountId, library, language };
		const cached = this.libraryUsageCache.get(cacheKey);
		if (cached) {
			return cached;
		}
		const urlParams = new URLSearchParams({
			library,
		});
		if (language) {
			urlParams.append("language", language);
		}
		const queryString = urlParams.toString();

		const path = `/v1/inventory/accounts/${accountId}/library?${queryString}`;
		const response = await this.get<LibraryUsage>(path, undefined, options);
		this.libraryUsageCache.put(cacheKey, response.body);
		return response.body;
	}
}
